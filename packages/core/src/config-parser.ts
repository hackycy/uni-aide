import type * as t from '@babel/types'
import fs from 'node:fs'
import path from 'node:path'
import process from 'node:process'
import MagicString from 'magic-string'
import { babelParse, findCommentBelongsToNode, getPropertyKey } from './ast'

const AVAILABLE_CONFIG_EXTENSIONS = ['ts', 'mts', 'cts', 'js', 'mjs', 'cjs']
const COMMENT_SYMBOL_PREFIX = '__uni_aide_comment__'

export interface ParseOptions {
  /**
   * 工作目录
   * @default process.cwd()
   */
  cwd?: string
}

/**
 * 解析配置文件
 * @description https://ast-explorer.dev/
 */
export async function parse(name: string, options: ParseOptions = {}) {
  const cwd = options.cwd || process.cwd()

  const preprocessJson = await loadConfigFile(name, cwd)

  const resultCode = `export default ${preprocessJson}`
  // 将预处理后的 JSON 代码再解析一遍，转换注释标记为注释
  const ast = babelParse(resultCode, 'js', {
    attachComment: true,
    sourceType: 'module',
  })

  const s = new MagicString(resultCode)

  // 找到 export default 对应的节点
  const exportDefaultNode = ast.body.find(
    node => node.type === 'ExportDefaultDeclaration',
  ) as t.ExportDefaultDeclaration | undefined
  if (!exportDefaultNode) {
    // never reach
    throw new Error('internal parser error')
  }

  // 配置对象
  let configObject: t.ObjectExpression | undefined

  if (exportDefaultNode.declaration.type === 'ObjectExpression') {
    // export default { ... }
    configObject = exportDefaultNode.declaration
  }

  if (!configObject) {
    // never reach
    throw new Error('internal parser error')
  }

  reverseComments(configObject, s)

  // 移除export default
  s.remove(exportDefaultNode.start!, exportDefaultNode.declaration.start!)

  return s.toString()
}

/**
 * 加载转换注释后的配置文件JSON字符串，用于二次处理
 */
export async function loadConfigFile(name: string, cwd: string) {
  // 查找配置文件
  const configPath = findConfigFile(cwd, name)

  if (!configPath) {
    throw new Error(`Config file not found: ${name}`)
  }

  const configExt = path.extname(configPath).toLowerCase()
  const transformedCode = await transformComments(configPath)

  // 生成临时文件
  const tempFilename = `${name}.timestamp-${Date.now()}`
  const tempFilePath = path.join(cwd, `${tempFilename}${configExt}`)
  fs.writeFileSync(
    tempFilePath,
    [
      '/* eslint-disable */',
      '/* prettier-ignore */',
      '// @ts-nocheck',
      '// Generated by @uni-aide/core',
      transformedCode,
    ].join('\n'),
    'utf-8',
  )

  // 加载临时文件（使用动态导入以支持 CommonJS）
  const { loadConfig } = await import('unconfig')

  try {
    const { config } = await loadConfig({
      sources: [
        {
          files: tempFilename,
          extensions: AVAILABLE_CONFIG_EXTENSIONS,
        },
      ],
      cwd,
    })

    return JSON.stringify(config, null, 2)
  }
  finally {
    // 删除临时文件
    fs.promises.rm(tempFilePath).catch(() => {})
  }
}

/**
 * 查找配置文件
 */
export function findConfigFile(root: string, name: string) {
  const candidates = AVAILABLE_CONFIG_EXTENSIONS.map(ext => `${name}.${ext}`)
  for (const candidate of candidates) {
    const filePath = path.join(root, candidate)
    if (fs.existsSync(filePath)) {
      return filePath
    }
  }
  return null
}

/**
 * 反向转换注释标记为条件编译注释
 */
export function reverseComments(node: t.Node, s: MagicString) {
  if (node.type === 'ObjectExpression') {
    for (const prop of node.properties) {
      if (prop.type !== 'ObjectProperty') {
        continue
      }

      const k = getPropertyKey(prop)
      if (!k) {
        continue
      }

      if (
        k.startsWith(COMMENT_SYMBOL_PREFIX)
        && prop.value.type === 'StringLiteral'
      ) {
        // 替换为注释
        s.overwrite(prop.start!, prop.end!, `//${prop.value.value}`)
        // 如果有尾随逗号则删除
        const nextChar = s.original.charAt(prop.end!)
        if (nextChar === ',') {
          s.remove(prop.end!, prop.end! + 1)
        }
      }
      else if (
        prop.value.type === 'ObjectExpression'
        || prop.value.type === 'ArrayExpression'
      ) {
        reverseComments(prop.value, s)
      }
    }
  }
  else if (node.type === 'ArrayExpression') {
    for (let i = 0; i < node.elements.length; i++) {
      const elem = node.elements[i]
      if (!elem) {
        continue
      }

      if (elem.type === 'ObjectExpression') {
        reverseComments(elem, s)
      }
      else if (elem.type === 'ArrayExpression') {
        // 判断是否是注释标记数组
        if (
          elem.elements.length === 2
          && elem.elements[0]
          && elem.elements[0].type === 'StringLiteral'
          && (elem.elements[0] as t.StringLiteral).value.startsWith(
            COMMENT_SYMBOL_PREFIX,
          )
          && elem.elements[1]
          && elem.elements[1].type === 'StringLiteral'
        ) {
          const commentValue = (elem.elements[1] as t.StringLiteral).value
          s.overwrite(elem.start!, elem.end!, `//${commentValue}`)
          // 如果有尾随逗号则删除
          const nextChar = s.original.charAt(elem.end!)
          if (nextChar === ',') {
            s.remove(elem.end!, elem.end! + 1)
          }
        }
        else {
          reverseComments(elem, s)
        }
      }
    }
  }
}

/**
 * 解析配置文件中的条件编译注释位置信息，并将其转换为带注释标记的配置对象 (V2版本)
 */
export async function transformComments(source: string) {
  const code = await fs.promises.readFile(source, 'utf-8')
  const ast = babelParse(code, 'ts', {
    attachComment: true,
    sourceType: 'module',
  })

  const s = new MagicString(code)

  if (ast.comments && ast.comments.length > 0) {
    ast.comments.forEach((comment) => {
      const node = findCommentBelongsToNode(comment, ast)
      if (!node) {
        return
      }

      const line = comment.loc!.start.line
      // 判断该父级节点是对象还是数组
      if (node.type === 'ObjectExpression') {
        s.overwrite(
          comment.start!,
          comment.end!,
          `"${COMMENT_SYMBOL_PREFIX}${line}": "${comment.value}",`,
        )
      }
      else if (node.type === 'ArrayExpression') {
        s.overwrite(
          comment.start!,
          comment.end!,
          `['${COMMENT_SYMBOL_PREFIX}${line}', "${comment.value}"],`,
        )
      }
    })
  }

  return s.toString()
}
